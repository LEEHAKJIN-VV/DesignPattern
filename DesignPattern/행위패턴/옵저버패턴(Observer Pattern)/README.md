# 옵저버 패턴

<aside>
한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의

</aside>

## 옵저버 패턴의 구조

<img src="https://user-images.githubusercontent.com/52197436/197337207-a8bdf739-3be4-4598-96b3-360f6ce59c06.png" width="40%" height="30%"></img>

- **Subject**:
주제를 나타내는 프로토콜로, 객체의 옵저버 등록, 탈퇴를 관리한다.
각 주제마다 한개 이상의 옵저버가 있을 수 있다.
- **Observer**: 옵저버가 될 객체는 반드시 이 프로토콜을 구현해야 한다.
프로토콜에는 주제의 상태가 바뀌었을 때 호출되는 `update` 메소드만 존재한다.
- **ConcreteSubject**: 주제 역할을 하는 클래스로, 항상 `Subject` 프로토콜을 구현해야 한다.
주제 클래스는 옵저버의 등록 및 해지를 하는 메소드와 상태가 바뀔 때마다 호출되는 `notifyObserver` 메소드도 구현해야 한다.
    - `WeatherData`
- **ConcreteObserver**: 옵저버 역할을 하는 클래스로, `Observer` 프로토콜을 반드시 구현해야 한다.
각 옵저버는 특정 주제에 등록해서 상태 변화에 대한 연락을 받을 수 있다.
    - `StaticsDispay`
    - `ForecastDisplay`
    - `HeatIndexDisplay`
    - `CurrentConditionDisplay`

## 느슨한 결합

- 느슨한 결합은 객체들이 상호작용할 수는 있지만, 서로 잘 모르는 관계를 의미한다. 느슨한 결합을 활용하면 유연성이 증가한다.
- 옵저버 패턴은 느슨한 결합을 사용한다.
    - 주제는 옵저버가 특정 프로토콜만 구현한다는 사실만 안다.
    - 옵저버는 언제든지 새로 추가할 수 있다.
    - 새로운 형식의 옵저버를 추가할 때도 주제를 변경할 필요가 전혀 없다.
    - 주제와 옵저버는 서로 독립적으로 재사용할 수 있다.
    - 주제나 옵저버가 달라져도 서로에게 영향을 미치지 않는다.

## 디자인 원칙

- 상호작용하는 객체 사이에는 가능하면 느슨한 결합을 사용해야한다.
- 느슨하게 결합하는 디자인을 사용하면 변경사항이 생겨도 무난히 처리할 수 있는 시스템을 구축할 수 있다.


## UML

![스크린샷 2022-10-22 오후 6 48 08](https://user-images.githubusercontent.com/52197436/197338057-25f7b097-687d-497e-978c-5b12889d8aef.png)


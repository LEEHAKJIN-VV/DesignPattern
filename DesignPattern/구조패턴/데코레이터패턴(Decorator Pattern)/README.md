# 데코레이터 패턴

- 객체에 추가 요소를 동적으로 더할 수 있으며, 데코레이터 패턴을 사용하면 상속을 이용하여 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있음


## 구조

![데코레이터패턴구조](https://user-images.githubusercontent.com/52197436/198878485-ce0dc741-0040-4ca3-a5d0-02165c1ebe06.png)


- Component
    - 구성요소는 직접 쓰이거나 데코레이터에 감싸여 쓰일 수 있음
    - Beverage
- Decorator
    - 구성요소(객체)를 장식할 프로토콜
    - 각 데코레이터 안에는 구성 요소의 레퍼런스를 포함한 인스턴스 변수가 존재함
    - 데코레이터는 자신이 장식할 구성 요소와 같은 인터페이스를 구현함
    - Moca, Milk, Soy, Whip
- ConcreteComponent
    - 구성요소를 상속한 클래스
    - 구성요소에 새로운 행동을 동적으로 추가함
    - Espresso, HouseBlend, Decaf, DarkRoast
- ConcreteDecorator
    - Decorator를 구현한 클래스
    - 데코레이터가 장식하고 있는 Component 타입의 변수가 존재

## 디자인 원칙
- 클래스는 확장에 열려 있어야 하지만 변경에는 닫혀 있어야 한다. (OCP: 개방-폐쇄 원칙)

## 정리

- 데코레이터의 슈퍼 클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같음
- 한 객체를 여러개의 데코레이터로 감쌀 수 있음
- 데코레이터는 자신이 감싸고 있는 객체와 같은 슈퍼클래스를 가지고 있기에 원래 객체(싸여 있는 객체)가 들어가 자리에 데코레이터 객체를 넣을 수 있음
- 데코레이터는 자신이 장식하고 있는 객체에 행동을 위임할 수 있고, 추가 작업을 수행할 수 있음
- 객체는 실행중에 필요한 데코레이터를 마음대로 적용할 수 있음
- 특정 형식에 의존하는 클라이언트 코드에 데코레이터 패턴을 적용하면 안됨
- 코드가 쓸데없이 복잡해질 수 있음

## UML

![데코레이터패턴uml](https://user-images.githubusercontent.com/52197436/198879533-f6febc8e-dbad-4df5-9149-39bf19db7d74.png)


